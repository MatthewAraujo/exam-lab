[
  {
    "question": "You want to deploy an application on Cloud Run that processes messages from a Cloud Pub/Sub topic. You want to follow Google-recommended practices. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "1. Create a Cloud Function that uses a Cloud Pub/Sub trigger on that topic. 2. Call your application on Cloud Run from the Cloud Function for every message.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "1. Grant the Pub/Sub Subscriber role to the service account used by Cloud Run. 2. Create a Cloud Pub/Sub subscription for that topic. 3. Make your application pull messages from that subscription.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "1. Create a service account. 2. Give the Cloud Run Invoker role to that service account for your Cloud Run application. 3. Create a Cloud Pub/Sub subscription that uses that service account and uses your Cloud Run application as the push endpoint.",
        "correct": true,
        "why": ""
      },
      "D": {
        "answer": "1. Deploy your application on Cloud Run on GKE with the connectivity set to Internal. 2. Create a Cloud Pub/Sub subscription for that topic. 3. In the same Google Kubernetes Engine cluster as your application, deploy a container that takes the messages and sends them to your application.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You need to deploy an application, which is packaged in a container image, in a new project. The application exposes an HTTP endpoint and receives very few requests per day. You want to minimize costs. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "Deploy the container on Cloud Run.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Deploy the container on Cloud Run on GKE.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Deploy the container on App Engine Flexible.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Deploy the container on GKE with cluster autoscaling and horizontal pod autoscaling enabled.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your company has an existing GCP organization with hundreds of projects and a billing account. Your company recently acquired another company that also has hundreds of projects and its own billing account. You would like to consolidate all GCP costs of both GCP organizations onto a single invoice. You would like to consolidate all costs as of tomorrow. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "Link the acquired company's projects to your company's billing account.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Configure the acquired company's billing account and your company's billing account to export the billing data into the same BigQuery dataset.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Migrate the acquired company's projects into your company's GCP organization. Link the migrated projects to your company's billing account.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Create a new GCP organization and a new billing account. Migrate the acquired company's projects and your company's projects into the new GCP organization and link the projects to the new billing account.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You built an application on Google Cloud that uses Cloud Spanner. Your support team needs to monitor the environment but should not have access to table data.You need a streamlined solution to grant the correct permissions to your support team, and you want to follow Google-recommended practices. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "Add the support team group to the roles/monitoring.viewer role",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Add the support team group to the roles/spanner.databaseUser role.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Add the support team group to the roles/spanner.databaseReader role.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Add the support team group to the roles/stackdriver.accounts.viewer role.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "For analysis purposes, you need to send all the logs from all of your Compute Engine instances to a BigQuery dataset called platform-logs. You have already installed the Cloud Logging agent on all the instances. You want to minimize cost. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "1. Give the BigQuery Data Editor role on the platform-logs dataset to the service accounts used by your instances. 2. Update your instances' metadata to add the following value: logs-destination: bq://platform-logs.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "1. In Cloud Logging, create a logs export with a Cloud Pub/Sub topic called logs as a sink. 2. Create a Cloud Function that is triggered by messages in the logs topic. 3. Configure that Cloud Function to drop logs that are not from Compute Engine and to insert Compute Engine logs in the platform-logs dataset.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "1. In Cloud Logging, create a filter to view only Compute Engine logs. 2. Click Create Export. 3. Choose BigQuery as Sink Service, and the platform-logs dataset as Sink Destination.",
        "correct": true,
        "why": ""
      },
      "D": {
        "answer": "1. Create a Cloud Function that has the BigQuery User role on the platform-logs dataset. 2. Configure this Cloud Function to create a BigQuery Job that executes this query: INSERT INTO dataset.platform-logs (timestamp, log) SELECT timestamp, log FROM compute.logs WHERE timestamp > DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) 3. Use Cloud Scheduler to trigger this Cloud Function once a day.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You are using Deployment Manager to create a Google Kubernetes Engine cluster. Using the same Deployment Manager deployment, you also want to create aDaemonSet in the kube-system namespace of the cluster. You want a solution that uses the fewest possible services. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "Add the cluster's API as a new Type Provider in Deployment Manager, and use the new type to create the DaemonSet.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Use the Deployment Manager Runtime Configurator to create a new Config resource that contains the DaemonSet definition.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "With Deployment Manager, create a Compute Engine instance with a startup script that uses kubectl to create the DaemonSet.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "In the cluster's definition in Deployment Manager, add a metadata that has kube-system as key and the DaemonSet manifest as value.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You are building an application that will run in your data center. The application will use Google Cloud Platform (GCP) services like AutoML. You created a service account that has appropriate access to AutoML. You need to enable authentication to the APIs from your on-premises environment. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "Use service account credentials in your on-premises application.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Use gcloud to create a key file for the service account that has appropriate permissions.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Set up direct interconnect between your data center and Google Cloud Platform to enable authentication for your on-premises applications.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Go to the IAM & admin console, grant a user account permissions similar to the service account permissions, and use this user account for authentication from your data center.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You are using Container Registry to centrally store your company's container images in a separate project. In another project, you want to create a GoogleKubernetes Engine (GKE) cluster. You want to ensure that Kubernetes can download images from Container Registry. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "In the project where the images are stored, grant the Storage Object Viewer IAM role to the service account used by the Kubernetes nodes.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "When you create the GKE cluster, choose the Allow full access to all Cloud APIs option under 'Access scopes'.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Create a service account, and give it access to Cloud Storage. Create a P12 key for this service account and use it as an imagePullSecrets in Kubernetes.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Configure the ACLs on each image in Cloud Storage to give read-only access to the default Compute Engine service account.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You are setting up a Windows VM on Compute Engine and want to make sure you can log in to the VM via RDP. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "After the VM has been created, use your Google Account credentials to log in into the VM.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "After the VM has been created, use gcloud compute reset-windows-password to retrieve the login credentials for the VM.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "When creating the VM, add metadata to the instance using 'windows-password' as the key and a password as the value.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "After the VM has been created, download the JSON private key for the default Compute Engine service account. Use the credentials in the JSON file to log in to the VM.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You want to configure an SSH connection to a single Compute Engine instance for users in the dev1 group. This instance is the only resource in this particularGoogle Cloud Platform project that the dev1 users should be able to connect to. What should you do?",
    "multichoice": false,
    "alternatives": {
      "A": {
        "answer": "Set metadata to enable-oslogin=true for the instance. Grant the dev1 group the compute.osLogin role. Direct them to use the Cloud Shell to ssh to that instance.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Set metadata to enable-oslogin=true for the instance. Set the service account to no service account for that instance. Direct them to use the Cloud Shell to ssh to that instance.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Enable block project wide keys for the instance. Generate an SSH key for each user in the dev1 group. Distribute the keys to dev1 users and direct them to use their third-party tools to connect.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Enable block project wide keys for the instance. Generate an SSH key and associate the key with that instance. Distribute the key to dev1 users and direct them to use their third-party tools to connect.",
        "correct": false,
        "why": ""
      }
    }
  }
]