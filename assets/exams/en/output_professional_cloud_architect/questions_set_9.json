[
  {
    "question": "You have been engaged by your client to lead the migration of their application infrastructure to GCP. One of their current problems is that the on-premises high performance SAN is requiring frequent and expensive upgrades to keep up with the variety of workloads that are identified as follows: 20 TB of log archives retained for legal reasons; 500 GB of VM boot/data volumes and templates; 500 GB of image thumbnails; 200 GB of customer session state data that allows customers to restart sessions even if off-line for several days. Which of the following best reflects your recommendations for a cost-effective storage allocation?",
    "alternatives": {
      "A": {
        "answer": "Local SSD for customer session state data. Lifecycle-managed Cloud Storage for log archives, thumbnails, and VM boot/data volumes.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Memcache backed by Cloud Datastore for the customer session state data. Lifecycle-managed Cloud Storage for log archives, thumbnails, and VM boot/data volumes.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Memcache backed by Cloud SQL for customer session state data. Assorted local SSD-backed instances for VM boot/data volumes. Cloud Storage for log archives and thumbnails.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Memcache backed by Persistent Disk SSD storage for customer session state data. Assorted local SSD-backed instances for VM boot/data volumes. Cloud Storage for log archives and thumbnails.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your web application uses Google Kubernetes Engine to manage several workloads. One workload requires a consistent set of hostnames even after pod scaling and relaunches. Which feature of Kubernetes should you use to accomplish this?",
    "alternatives": {
      "A": {
        "answer": "StatefulSets",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Role-based access control",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Container environment variables",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Persistent Volumes",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You are using Cloud CDN to deliver static HTTP(S) website content hosted on a Compute Engine instance group. You want to improve the cache hit ratio. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Customize the cache keys to omit the protocol from the key.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Shorten the expiration time of the cached objects.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Make sure the HTTP(S) header Cache-Region points to the closest region of your users.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Replicate the static content in a Cloud Storage bucket. Point CloudCDN toward a load balancer on that bucket.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your architecture calls for the centralized collection of all admin activity and VM system logs within your project. How should you collect these logs from both VMs and services?",
    "alternatives": {
      "A": {
        "answer": "All admin and VM system logs are automatically collected by Stackdriver.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Stackdriver automatically collects admin activity logs for most services. The Stackdriver Logging agent must be installed on each instance to collect system logs.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Launch a custom syslogd compute instance and configure your GCP project and VMs to forward all logs to it.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Install the Stackdriver Logging agent on a single compute instance and let it collect all audit and access logs for your environment.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You have an App Engine application that needs to be updated. You want to test the update with production traffic before replacing the current application version. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Deploy the update using the Instance Group Updater to create a partial rollout, which allows for canary testing.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Deploy the update as a new version in the App Engine application, and split traffic between the new and current versions.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Deploy the update in a new VPC, and use Google's global HTTP load balancing to split traffic between the update and current applications.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Deploy the update as a new App Engine application, and use Google's global HTTP load balancing to split traffic between the new and current applications.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "All Compute Engine instances in your VPC should be able to connect to an Active Directory server on specific ports. Any other traffic emerging from your instances is not allowed. You want to enforce this using VPC firewall rules. How should you configure the firewall rules?",
    "alternatives": {
      "A": {
        "answer": "Create an egress rule with priority 1000 to deny all traffic for all instances. Create another egress rule with priority 100 to allow the Active Directory traffic for all instances.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Create an egress rule with priority 100 to deny all traffic for all instances. Create another egress rule with priority 1000 to allow the Active Directory traffic for all instances.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Create an egress rule with priority 1000 to allow the Active Directory traffic. Rely on the implied deny egress rule with priority 100 to block all traffic for all instances.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Create an egress rule with priority 100 to allow the Active Directory traffic. Rely on the implied deny egress rule with priority 1000 to block all traffic for all instances.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your customer runs a web service used by e-commerce sites to offer product recommendations to users. The company has begun experimenting with a machine learning model on Google Cloud Platform to improve the quality of results. What should the customer do to improve their model's results over time?",
    "alternatives": {
      "A": {
        "answer": "Export Cloud Machine Learning Engine performance metrics from Stackdriver to BigQuery, to be used to analyze the efficiency of the model.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Build a roadmap to move the machine learning model training from Cloud GPUs to Cloud TPUs, which offer better results.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Monitor Compute Engine announcements for availability of newer CPU architectures, and deploy the model to them as soon as they are available for additional performance.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Save a history of recommendations and results of the recommendations in BigQuery, to be used as training data.",
        "correct": true,
        "why": ""
      }
    }
  },
  {
    "question": "A development team at your company has created a dockerized HTTPS web application. You need to deploy the application on Google Kubernetes Engine (GKE) and make sure that the application scales automatically. How should you deploy to GKE?",
    "alternatives": {
      "A": {
        "answer": "Use the Horizontal Pod Autoscaler and enable cluster autoscaling. Use an Ingress resource to load-balance the HTTPS traffic.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Use the Horizontal Pod Autoscaler and enable cluster autoscaling on the Kubernetes cluster. Use a Service resource of type LoadBalancer to load-balance the HTTPS traffic.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Enable autoscaling on the Compute Engine instance group. Use an Ingress resource to load-balance the HTTPS traffic.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Enable autoscaling on the Compute Engine instance group. Use a Service resource of type LoadBalancer to load-balance the HTTPS traffic.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You need to design a solution for global load balancing based on the URL path being requested. You need to ensure operations reliability and end-to-end in- transit encryption based on Google best practices. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Create a cross-region load balancer with URL Maps.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Create an HTTPS load balancer with URL Maps.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Create appropriate instance groups and instances. Configure SSL proxy load balancing.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Create a global forwarding rule. Configure SSL proxy load balancing.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You have an application that makes HTTP requests to Cloud Storage. Occasionally the requests fail with HTTP status codes of 5xx and 429. How should you handle these types of errors?",
    "alternatives": {
      "A": {
        "answer": "Use gRPC instead of HTTP for better performance.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Implement retry logic using a truncated exponential backoff strategy.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Make sure the Cloud Storage bucket is multi-regional for geo-redundancy.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Monitor https://status.cloud.google.com/feed.atom and only make requests if Cloud Storage is not reporting an incident.",
        "correct": false,
        "why": ""
      }
    }
  }
]