[
  {
    "question": "Your company is designing its application landscape on Compute Engine. Whenever a zonal outage occurs, the application should be restored in another zone as quickly as possible with the latest application data. You need to design the solution to meet this requirement. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Create a snapshot schedule for the disk containing the application data. Whenever a zonal outage occurs, use the latest snapshot to restore the disk in the same zone.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Configure the Compute Engine instances with an instance template for the application, and use a regional persistent disk for the application data. Whenever a zonal outage occurs, use the instance template to spin up the application in another zone in the same region. Use the regional persistent disk for the application data.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Create a snapshot schedule for the disk containing the application data. Whenever a zonal outage occurs, use the latest snapshot to restore the disk in another zone within the same region.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Configure the Compute Engine instances with an instance template for the application, and use a regional persistent disk for the application data. Whenever a zonal outage occurs, use the instance template to spin up the application in another region. Use the regional persistent disk for the application data.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your company has just acquired another company, and you have been asked to integrate their existing Google Cloud environment into your company's data center. Upon investigation, you discover that some of the RFC 1918 IP ranges being used in the new company's Virtual Private Cloud (VPC) overlap with your data center IP space. What should you do to enable connectivity and make sure that there are no routing conflicts when connectivity is established?",
    "alternatives": {
      "A": {
        "answer": "Create a Cloud VPN connection from the new VPC to the data center, create a Cloud Router, and apply new IP addresses so there is no overlapping IP space.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Create a Cloud VPN connection from the new VPC to the data center, and create a Cloud NAT instance to perform NAT on the overlapping IP space.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Create a Cloud VPN connection from the new VPC to the data center, create a Cloud Router, and apply a custom route advertisement to block the overlapping IP space.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Create a Cloud VPN connection from the new VPC to the data center, and apply a firewall rule that blocks the overlapping IP space.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You need to migrate Hadoop jobs for your company's Data Science team without modifying the underlying infrastructure. You want to minimize costs and infrastructure management effort. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Create a Dataproc cluster using standard worker instances.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Create a Dataproc cluster using preemptible worker instances.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Manually deploy a Hadoop cluster on Compute Engine using standard instances.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Manually deploy a Hadoop cluster on Compute Engine using preemptible instances.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You need to deploy an application on Google Cloud that must run on a Debian Linux environment. The application requires extensive configuration in order to operate correctly. You want to ensure that you can install Debian distribution updates with minimal manual intervention whenever they become available. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Create a Compute Engine instance template using the most recent Debian image. Create an instance from this template, and install and configure the application as part of the startup script. Repeat this process whenever a new Google-managed Debian image becomes available.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Create a Debian-based Compute Engine instance, install and configure the application, and use OS patch management to install available updates.",
        "correct": true,
        "why": ""
      },
      "C": {
        "answer": "Create an instance with the latest available Debian image. Connect to the instance via SSH, and install and configure the application on the instance. Repeat this process whenever a new Google-managed Debian image becomes available.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Create a Docker container with Debian as the base image. Install and configure the application as part of the Docker image creation process. Host the container on Google Kubernetes Engine and restart the container whenever a new update is available.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You have an application that runs in Google Kubernetes Engine (GKE). Over the last 2 weeks, customers have reported that a specific part of the application returns errors very frequently. You currently have no logging or monitoring solution enabled on your GKE cluster. You want to diagnose the problem, but you have not been able to replicate the issue. You want to cause minimal disruption to the application. What should you do?",
    "alternatives": {
      "A": {
        "answer": "1. Update your GKE cluster to use Cloud Operations for GKE. 2. Use the GKE Monitoring dashboard to investigate logs from affected Pods.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "1. Create a new GKE cluster with Cloud Operations for GKE enabled. 2. Migrate the affected Pods to the new cluster, and redirect traffic for those Pods to the new cluster. 3. Use the GKE Monitoring dashboard to investigate logs from affected Pods.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "1. Update your GKE cluster to use Cloud Operations for GKE, and deploy Prometheus. 2. Set an alert to trigger whenever the application returns an error.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "1. Create a new GKE cluster with Cloud Operations for GKE enabled, and deploy Prometheus. 2. Migrate the affected Pods to the new cluster, and redirect traffic for those Pods to the new cluster. 3. Set an alert to trigger whenever the application returns an error.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You need to deploy a stateful workload on Google Cloud. The workload can scale horizontally, but each instance needs to read and write to the same POSIX filesystem. At high load, the stateful workload needs to support up to 100 MB/s of writes. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Use a persistent disk for each instance.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Use a regional persistent disk for each instance.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Create a Cloud Filestore instance and mount it in each instance.",
        "correct": true,
        "why": ""
      },
      "D": {
        "answer": "Create a Cloud Storage bucket and mount it in each instance using gcsfuse.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your company has an application deployed on Anthos clusters (formerly Anthos GKE) that is running multiple microservices. The cluster has both Anthos ServiceMesh and Anthos Config Management configured. End users inform you that the application is responding very slowly. You want to identify the microservice that is causing the delay. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Use the Service Mesh visualization in the Cloud Console to inspect the telemetry between the microservices.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Use Anthos Config Management to create a ClusterSelector selecting the relevant cluster. On the Google Cloud Console page for Google Kubernetes Engine, view the Workloads and filter on the cluster. Inspect the configurations of the filtered workloads.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Use Anthos Config Management to create a namespaceSelector selecting the relevant cluster namespace. On the Google Cloud Console page for Google Kubernetes Engine, visit the workloads and filter on the namespace. Inspect the configurations of the filtered workloads.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Reinstall istio using the default istio profile in order to collect request latency. Evaluate the telemetry between the microservices in the Cloud Console.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "You are working at a financial institution that stores mortgage loan approval documents on Cloud Storage. Any change to these approval documents must be uploaded as a separate approval file, so you want to ensure that these documents cannot be deleted or overwritten for the next 5 years. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Create a retention policy on the bucket for the duration of 5 years. Create a lock on the retention policy.",
        "correct": true,
        "why": ""
      },
      "B": {
        "answer": "Create the bucket with uniform bucket-level access, and grant a service account the role of Object Writer. Use the service account to upload new files.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Use a customer-managed key for the encryption of the bucket. Rotate the key after 5 years.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Create the bucket with fine-grained access control, and grant a service account the role of Object Writer. Use the service account to upload new files.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your team will start developing a new application using microservices architecture on Kubernetes Engine. As part of the development lifecycle, any code change that has been pushed to the remote develop branch on your GitHub repository should be built and tested automatically. When the build and test are successful, the relevant microservice will be deployed automatically in the development environment. You want to ensure that all code deployed in the development environment follows this process. What should you do?",
    "alternatives": {
      "A": {
        "answer": "Have each developer install a pre-commit hook on their workstation that tests the code and builds the container when committing on the development branch. After a successful commit, have the developer deploy the newly built container image on the development cluster.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Install a post-commit hook on the remote git repository that tests the code and builds the container when code is pushed to the development branch. After a successful commit, have the developer deploy the newly built container image on the development cluster.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "Create a Cloud Build trigger based on the development branch that tests the code, builds the container, and stores it in Container Registry. Create a deployment pipeline that watches for new images and deploys the new image on the development cluster. Ensure only the deployment tool has access to deploy new versions.",
        "correct": true,
        "why": ""
      },
      "D": {
        "answer": "Create a Cloud Build trigger based on the development branch to build a new container image and store it in Container Registry. Rely on Vulnerability Scanning to ensure the code tests succeed. As the final step of the Cloud Build process, deploy the new container image on the development cluster. Ensure only Cloud Build has access to deploy new versions.",
        "correct": false,
        "why": ""
      }
    }
  },
  {
    "question": "Your operations team has asked you to help diagnose a performance issue in a production application that runs on Compute Engine. The application is dropping requests that reach it when under heavy load. The process list for affected instances shows a single application process that is consuming all available CPU, and autoscaling has reached the upper limit of instances. There is no abnormal load on any other related systems, including the database. You want to allow production traffic to be served again as quickly as possible. Which action should you recommend?",
    "alternatives": {
      "A": {
        "answer": "Change the autoscaling metric to agent.googleapis.com/memory/percent_used.",
        "correct": false,
        "why": ""
      },
      "B": {
        "answer": "Restart the affected instances on a staggered schedule.",
        "correct": false,
        "why": ""
      },
      "C": {
        "answer": "SSH to each instance and restart the application process.",
        "correct": false,
        "why": ""
      },
      "D": {
        "answer": "Increase the maximum number of instances in the autoscaling group.",
        "correct": true,
        "why": ""
      }
    }
  }
]